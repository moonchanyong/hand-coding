
# hand-coding
한글로 한다 손 코 딩 용 코 드

## sorting

### mergesort

```javascript
// immutable 원칙 안지킴, index저장하는 변수 만드는게 더 효율적이지만 간편한 코딩을위해
 function merge(arrA, arrB) {
  ret = [];
  while(arrA.length !=0 || arrB.length != 0)
    if(arrA.length == 0 || arrA[0] >= arrB[0]) ret.push(arrB.shift());
    else ret.push(arrA.shift());
  return ret;
}

function mergeSort(inputArr) {
  if(inputArr.length < 2) return inputArr;

  return merge(
    mergeSort(inputArr.slice(0, inputArr.length/2)),
    mergeSort(inputArr.slice(inputArr.length/2))
  );
}
```

## search

## named problem

### TSP(boj2098)
```java
int tsp(int[][] map) {
  int dp[16][65537];

}
```




# 예상 면접 질문 답변 리스트

## 백엔드



### 컴포넌트와 모듈의 차이

* 목적은 공통점 전체시스템을 구성하는 부분부분으로 분해시키는 것

####  모듈
* 모듈의 경우 가장 첫 번째 그리고 가장 맨 앞의 위치하는 구현의 단위
* 모듈설계에서 기본적인 작업은 은닉,캡슐화를 기준으로 사용
* 가장 상위의 구현의 단위
* 인터페이스가 될수 있다.

#### 컴포넌트
* 컴포넌트는 런타임 개체를 참조한다.
* 독립적으로 배포 될 수 있고, 써드파티로부터의 결합 대상

출처에 배경부터 잘써져있다.
[출처]http://imcreator.tistory.com/7

### 자바란 무엇인가.
WORA(Write Once Run Anywhere), 미친 호환성을 말하는듯
#### 자바의 구동원리(순서가 아닌가 이게 왜 원리)
* 소스코드 작성 -> 컴파일러(javac.exe)가 소스코드를 바이트코드로 변환 (.class)
* 런처(java.exe)로 JVM을 구동시킨다.
* JVM이 바이트 코드를 해석하여 자바 프로그램이 실행된다.
#### 자바 큰 특징

* 자바 컴파일러는 자바언어로 작성된 프로그램을 바이트 코드로 변환한다.
* 바이트코드는 JVM에서 인터프리터처럼 실행된다.
* JVM은 어느 플랫폼에서나 동일한 형태로 실행시킨다.
* 자바 프로그램은 JVM을 설치할 수 있는 시스템 어디서나 실행 할 수 있다.
* 스택머신(JVM)
#### 분산환경을 지원한다.
* 자바에선 TCP/IP 라이브러리와 http/https 프로토콜을 기본적으로 지원

#### 인터프리터 언어이다.
* 컴파일 언어인 동시에 인터프리터 언어
* 컴파일 후 바이트코드를 인터프리트 하면서 실행
* 시스템에 무관한 바이트코드(2진 파일)을 만들어서 컴파일 언어에 가까운 속도와 시스템 독립성을 동시에 얻는다.

#### 멀티쓰레딩을 지원한다.
* 프로그램 단위가 동일한 쓰레드를 동시에 수행 할 수 있다.
* 사용자 인터페이스 쓰레드와 장시간 계산이 필요한 쓰레드가 동시에 필요할 때 효과적이다.

#### GC
* Garbage Collection, 사용하지 않는 메모리를 체크하고 반환한다.
* 이로인해 성능이 안좋다.

#### 동적로딩을 지워한다.(lazy load)
* 필요한 시점에 클래스를 로딩하여 사용할 수 있다는 장점
* 앱의 변경사항이 발생해도 비교적 적은 작업만으로도 처리할 수  있는 유연한 앱 작성 가능(왜냐면 동적 로딩을 지원 한다는 것은 클래스 사이의 의존성이 적다는것이라고 판단)

### JVM특징 JRE(JVM + JAVA_API)

자바 바이트 코드는 JRE위에서 동작한다.(엥? JVM이라메)
JRE는 자바 API와 JVM으로 구성되며, JVM의 역할은 자바 앱을 클래스 로더를 통해 읽어 들여서 자바 API와 함께 실행하는 것이다.

#### JVM 특징
* 스택 기반의 가상 머신
* GC: 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되어 가바지 컬렉션에 의해 자동으로 파괴
* 네트워크 바이트 오더를 사용한다.(TCP/IP, http/s 등등 네트워크에 대해 준비가 많이 되있다.) 빅엔디안을 쓴다.

#### 자바 바이트 코드(.class)
* WORA를 위해서 바이트코드를 사용
* 자바코드를 배포하는 가장 작은 단위


#### 구조
![Alt text](https://d2.naver.com/content/images/2015/06/helloworld-1230-1.png)
* 클래스 로더가 바이트코드를 로드해서 런타임 데이터 영역에 로드한다
* 실행엔진이 이 바이크코드를 실행한다.


### 객체지향과 절차지향의 차이점

#### 절차지향
* 전체가 유기적으로 연결되도록 한다.
* 컴퓨터의 작업 처리 방식과 유사하기 때문에 객체지향 언어를 사용하는것에 비해 더 빠릴 처리되어 시간적유리하였다.(과거)
* 단점으로 유기적인 연결때문에 유지관리가 힘들다.
#### 객체지향
* 실제 세계를 모델링하여 개발
* 캡슐화
* 상속
* 다형성
* 코드를 재사용하기 쉽다.
* 업그레이드가 쉽다.
* 디버깅이 쉽다.

### 객체지향 언어의 특징
* (객체지향 프로그래밍의 특징이 아닐까 싶지만)
* 캡슐화와 데이터 은닉
* 다형성과 메소드 오버로딩
* 상속성

### 상속과 구현(인터페이스)의 차이점 과 특징 및 장단점

#### 차이점
* 상속은 메소드 변경이 일어날때만 메소드를 다시 정의(오버라이딩) 하면 되지만 구현은 필수로 구현해야한다.
* 상속은 다중상속을 지원하지 않는 경우가 있지만 인터페이스의 구현같은경우는 다중상속이 가능하다.
* 상속은 is-a, 구현은 can-do;
#### 특징
* 상속은 패런츠 변수에 차일드를 담을수 있다.
* 구현 같은경우는

####상속의 장단점
* 장점: 공통메소드를 사우이크랠스에서 상속하여 사용하여 소스코드의 양이 줄어들고 확장이 용이하다.
* 단점: 상속구조가 복잡해지면 상위클래스의 변화가 하위클래스에 주는 영향을 예측하기 힘들다.

#### 구현의 장단점
* 장점: 다중구현이 가능하다.
* 단점: 인터페이스의 내용이 바뀌면 이를 구현하는 모든 클래스의 소스가 변경되야한다.

#### 오버라이딩 오버로딩의 차이점과 특징
오버라이딩: 상위 클래스의 메소드를 하위클래스에서 재구현
오버로딩: 여러개의 메소드가 이름은 같고, 파라미터가 다르다. 파라미터에 따라 실행된다.

### 자바의 기본형(Primitive) 변수와 참조형(reference) 변수

#### 기본형 변수
* 이미 알고잇는 각 타입들
* 스택에 할당된다.
* 값 타입으로 간주되는 기본형 변수는 기본형 값을 갖는 메모리 위치

#### 참조형 변수
* 객체와 관련된 데이터가 저장된 메모리 주소
* 힙에 할당된다.
* 프로그래머가 메모리 주소를 직접 참조하는 것은 불가능하다.


### 스택오버플로우가 일어나는 이유
* 스택 포인터가 스택의 경계를 넘어 설 때 일어난다.
* 호출 스택은 제안된 양의 주소 공간을 이루며 대개 프로그램 시작 시 결정되는데, 프로그램이 호출 스택에서 이용 가능한 공간 이상을 사용하려고 시도할 때 스택오버 플로우가 일어난다.
[출처] 위키백과

### 메모리 누수가 무엇인가.
* 필요하지 않은 메모리를 계속 점유하고 있는형상, 사용 후 반환하지 않고 누적되면 메모리가 낭비
* garbage collector가 작동을해도 일어날수있다.
* 멀티스레드 환경에서 스레드 세이프를 고려하지 않은 코드를 사용했을경우
[출처] 위키백과

### 메모리 누수를 막기위해 어떻게 해야하나
* 지역변수의 경유 디스트럭터 명시 (자바에서는 null로 바꾼다.)

### static에 대해서
* 모든 객체들이 하나만 공유함
* static으로 선언하면 constand영역에 할당, 객체가 선언되지않아도 자원에 접근가능
#### 그냥 singleton과 비교
* 싱글톤 패턴은 클래스를 확장하고 인터페이스르르 구현할 수 있지만 static클래스는 확장 할 수는 있지만인스턴스 멤버를 상속하지 않는다.
* 싱글톤은 느린 또는 비동기 적으로 초기화 될 수 있지만 static 클래스는 일반적으로 처음 로드 될때 초기화 된다. 싱글톤은 단 하나의 인스턴스만 있다고 가정하도록 강요하지 않으면서 다형적으로 처리 가능하다.
* 멀티스레드의 경우 차이가 난다!!! 그리고lazy loading이 필요하냐 마느냐의 문제로 판단
* 멀티스레드의 경우에도 static은 하나만 공유, 싱글톤이 모든 스레드까지 싱글톤이아니라면 해등 쓰레드 내부에서만해서 스레드 개수만큼 증가

### 싱글턴이 무엇인가 ? 디자인패턴을 아나 ?

#### singleton
``` java
// 동시성 문제 해결
public class Singleton{
  private Singleton() {}
  // volatile: 컴파일러 옵티마이저가 캐싱하지 못하게 한다. 그러므로 멀티 스레드 환경에서 새로 호출함 
  private static volatile Singleton singleton = new Singleton();
  public static Singleton getStingletonObject {
    return singleton;
  }
}
```

### 익명클래스와 익명객체를 아나?
* 무명 클래스 : 하나의 객체만 사용 할 경우, ClassName VarName = new ClassNam {클래수 구현 내용};
* 무명 객체 : 무명클래스를 통해 인터페이스를 구현하고 하는 일회성의 구현 객체 InterfaceType VarName = new InterfaceType() {인터페이스 추상메소드의 구현}
[출처] http://movefast.tistory.com/34

### 문자열을 끊어서 가져오거나 문자열 검색
* 이거 함수를 물어보는거 아닌거같은데 ㅎㅎ..
* 알고리즘틱 하게 말하지면 문자열 검색 알고리즘은 KMP
* 문자열 끊는건 memcpy를 통하여 인덱스 자르기

### 자료구조

벡터와 리스트의 차이
* 벡터는 연속적인 메모리, 리스트는 비연속적 (이부분 속도에서 차이날듯)
* 벡터: 미래에 들어갈 요소를 위해 선할당, 리스트: 메모리 선할당을 하지않는다
* 벡터: 각요소는 요소타입 그자체만큼의 공간을 요구,리스트: 앞 뒤 element의 포인터를 가지고있어서 추가 공간이 필요
* 벡터: 추가 메모리 필요시 메모리 재할당 해야한다,리스트: 재할당 할 필요 없다. (리스트가 좋음)
* 벡터: 끝부분 추가는 상수시간이지만 다른곳은 N타임,리스트: 추가와 제거 비용이싸다 (이거 아님 ㅡㅡ N임 원소 접근 시간 생각안함, 타임컴플렉시티는 같아)
* 납득하지 못하는 부분 많아서 더이상 안쓴다.

* 벡터: 맨뒤에 추가제거가 일어나는경우는 벡터가 빠르고 메모리도 적게듬, 리스트: 중간위치에서는 더 빠르다(음.. 메모리의 연속적인거는 없지 하지만 서치시간이 포함된다면 어떨지 모르는거 아닐까 싶다.)

### 다중접속을 구현하는방법 3가지
* 실제 요청을 처리하는 쓰레드는 이벤트루프 단일쓰레드
* 노드는 비동기적 I/O모델을 사용, 단일쓰레드로 알려져있지만 내부적으로는 멀티 쓰레드풀을 사용

#### 멀티 프로세스 사용
* 장점은 안정성, 메모리침범에 의한 문제를 OS에서 처리
* 단점은 경제성
* 클라이언트와 서버간의 송수신 데이터의 용량이 큰경우 적합
* 송수신이 쉬지않고 연속적으로 발생하는 경우 적합
* 구현이 비교적 간단하고, 각프로세스들이 독립적으로 움직여서 자원이 서로 다르게할당
* 병렬처리 해야하는 만큼의 프로세스 생성으로 메모리와 스케쥴링의 횟수가 많아지고 성능저하
#### 멀티 스레드 사용
* 멀티 프로세스 처리보다 자워점유가 적으며, 스레드 생성시간이 짧다
* 전역벽수 공유 문제와, 동기화 문제가 발생 할 우려가 있다.
* 경제성은 좋지만 안정성, 스레드 하나죽으면 다죽는다.
#### 멀티 플렉싱
* select 함수 또는 epoll함수를 이용하여 하나의 프로세스로 서버구현
* 클라이언트와 서버 간의 송수신 데이터용량 이 작은 경우 적합
* 송수신이 연속적이지 않은 경우 적합
* 멀티 프로세스 기반에 비해 많은 수의 클라리언트 처리에 적합
* 만들기도 쉽고 비교적 쉽다.
* 하지만 요즘 대세인 멀티프로세서를 제대로 활용하기 어렵다.

### 스레드는 언제쓰고 쓰레드가 무엇인가
* 응답성, 대화형 프로그램같은
* 프로세스 생성에는 많은 자원이 들지만 스레드는 자신이 속한 프로세스의 자원들을 공유
* 멀티프로세서 구조에서 각각의 스레드가 다른 프로세서에서 병렬로 수행 될 수 있다. 단일스레드 프로세스는 CPU가 많아도 한개의 CPU에서 실행되지만, 다중 스레드화를 하면 다중 CPU에서 병렬성이 증가
* KLDP 답변: 멀티프로세스보다 훨씬 좋을때, non-block io를 쓰는데, 작업들이 서로 간섭을 하지않는다

### 제네릭이 무엇인가?
* 제네릭은 데이터타입이 미리 정의되지않았을때 클래스를 인스턴스화 하는 시점에 데이터타입을 지정해주는 방식을 가능케 해줌
* 성능 저하를 유발하는 타입캐스팅을 제거
* 각 타입에 대해서 구현 할 필요가 없어서 반복적인코드 절약과 코드재사용성이 좋아진다.
* 컴파일시 타입체크가 가능(의도한 데이터 입이 아닌경우)

### 람다식
* 익명함수를 지칭하는 용어, 코드 간결성과 lazy evalution을 통해 효율적인 퍼포먼스가 가능
* 로직으르 강화하거나 변경하기 쉽다.
* 메소드를 사용할때 이터레이션은 라이브러리에 의해 제어된다.
* 루프에 lazy evaluation이 가능하다.ㄴ
* 원하는 부분을 병렬화 하기 쉽다.

### 힙과 스택의 차이점
#### DATA영역
* 전역 변수와 static 변수가 할당되는 여영ㄱ
* 프로그램의 시작과 동시에 할당되고, 프로그램이 종료되어야 메모리에서 소멸
#### STACK 영역
* 함수 호출 시 생성되는 지역변수와 매개변수가 저장되는 영역
* 함수 호출이 완료도면 사라짐
#### HEAP 영역
* 필요에 의해 동적으로 메모리 할당 할 때 사용
* 할당해야 할 메모리의 크기를 프로그램이 실행되는 동안 결정해야 하는 경우
* 완전이진트리를 기본으로 한 자료구조

### TCP와 UDP의 차이점
* TCP: 연결지향형으로 패킷의 검사 및 오류시 재송출을 한다. 그래서 UDP보다 느리지만 안정적 흐름제어 혼잡제어, threeway handshaking, 4 way handshaking
* UDP: 비연결지향형, 데이터그램형 프로토콜 방식으로 TCP와달리 검사및 오류시 재송출을 안하므로 빠르다. 하지만 손실 되는 패킷이 존재할 수 있다. 오버헤드가 적음, 비신뢰성

### http(Hyper Texxt Transfer Protocol) 프로토콜
* 서버/클라이언트의 모델을 따르는 프로토콜, 애플리케이션 레벨, TCP/IP에서 작동
* Hypertext가 붙은 이유는 하이퍼텍스트 기반으로 데이터를 전송 링크기반 데이터 접속
* 클라이언트에서 요청을 보내면 서버는 요청을 처리해서 응답
* connectless 방식으로  연결을 요청하여 응답을 받으면 연결을 끊는다. (keep-alive로 일정시간 열리도록 설정가능 1.1 추가)
* URL: URL을 통해서 자원의 위치를 찾는다.
* 메서드: 요청의 종류를 서버에서 알려주기 위해서 사용, 여러가지있음(RESTful API서버는 GET, POST, PUT, DELETE를 사용 REST란 HTTPURL로 정의된 리소스를 HTTP메소드와 PAYload로 잘정의된 API)

### SQL injection 방지
* OWASP에서는 개발자가 입력 유효성검사를 화이트리스팅해 매개변수화된 쿼리가 있는 준비된 문을 사용하고 모든 사용자 입력을 이스케이프 해야한다.
* 계정권한을 제한, 최소한의 권한을 부여한다.
* 입력값 검사
